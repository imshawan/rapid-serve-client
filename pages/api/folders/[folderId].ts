import { NextApiRequest, NextApiResponse } from "next"
import { Types } from "mongoose"
import _ from "lodash"
import { initializeDbConnection } from "@/lib/db"
import { authMiddleware } from "@/lib/middlewares"
import { ApiError, ErrorCode, formatApiResponse, HttpStatus, paginate } from "@/lib/api/response"
import { File } from "@/lib/models/upload"
import { Shared } from "@/lib/models/shared"

async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    await initializeDbConnection()
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  } catch (error) {
    return formatApiResponse(res, new ApiError(ErrorCode.INTERNAL_ERROR, "Error connecting to the database", HttpStatus.INTERNAL_SERVER_ERROR), String(req.url));
  }

  switch (req.method) {
    case "GET":
      return await get(req, res);

    default:
      return formatApiResponse(res, new ApiError(ErrorCode.METHOD_NOT_ALLOWED, "Method Not Allowed", HttpStatus.METHOD_NOT_ALLOWED), String(req.url));
  }
}

/**
 * Handles the GET request to fetch folder contents and metadata.
 * 
 * @param req - The Next.js API request object.
 * @param res - The Next.js API response object.
 * 
 * @returns A JSON response containing paginated files, breadcrumbs, and folder metadata.
 * 
 * @throws {ApiError} If the folder is not found or the user is not authorized to access it.
 * @throws {ApiError} If there is an internal server error while fetching folder contents.
 * 
 * @remarks
 * - The function checks if the folder exists and if the user has access to it.
 * - It supports pagination, field selection, search, and sorting.
 * - Breadcrumbs are generated by traversing up the folder hierarchy.
 * 
 * @example
 * Example request:
 * GET `/api/folders/12345?page=1&limit=10&fields=fileName,createdAt&search=report&sort=asc&sortBy=fileName`
 * 
 * @example
 * Example response:
 * {
 *   "paginated": {
 *     "data": [...],
 *     "total": 100,
 *     "limit": 10,
 *     "page": 1,
 *     "pages": 10
 *   },
 *   "breadcrumbs": [...],
 *   "folder": {...}
 * }
 */
async function get(req: NextApiRequest, res: NextApiResponse) {
  const userId = new Types.ObjectId(req.user?.userId)
  const { folderId, page, limit, fields, search, sort, sortBy } = req.query as { [key: string]: string }
  const pageNumber = parseInt(page as string, 10),
    limitNumber = parseInt(limit as string, 10),
    fieldArray = (fields as string)?.split(",").filter(Boolean) || [],
    sortDirection = sort?.toString().toUpperCase() === "ASC" ? 1 : -1,
    sortOptions: any = { updatedAt: sortDirection };

  if (sortBy && ["fileName", "fileSize", "createdAt", "updatedAt"].includes(String(sortBy))) {
    if (String(sortBy) === "fileName") {
      // Use collation for case-insensitive string sorting
      sortOptions.collation = { locale: "en", strength: 2 }
    }
    sortOptions[String(sortBy)] = sortDirection
    delete sortOptions.updatedAt
  }

  try {
    // Check if folder exists and user has access to it
    const [folder, sharedWithMe] = await Promise.all([
      File.findOne({ fileId: folderId, type: "folder" }).select("-_id fileId userId fileName thumbnail"),
      Shared.findOne({ fileId: folderId, "sharedWith.userId": String(userId) })
    ])

    if (!folder) {
      throw new ApiError(ErrorCode.NOT_FOUND, "Folder not found", HttpStatus.NOT_FOUND)
    }

    if (String(folder.userId) != String(userId) && !sharedWithMe) {
      throw new ApiError(ErrorCode.FORBIDDEN, "You are not authorized to preview this resource", HttpStatus.FORBIDDEN)
    }

    const fieldSelection = (fieldArray.length ? fieldArray.join(" ") : "") + "-chunkHashes -storageNode -_id -__v"
    const query: Record<string, any> = { userId: new Types.ObjectId(userId), status: "complete", parentId: folderId }

    if (search) {
      query.fileName = { $regex: new RegExp(_.escapeRegExp(String(search)), "i") }
    }

    const [files, total] = await Promise.all([
      File.find(query)
        .select(fieldSelection)
        .sort(sortOptions)
        .skip((pageNumber - 1) * limitNumber)
        .limit(limitNumber)
        .lean(),
      File.countDocuments(query)
    ])

    const paginatedFiles = paginate(files, total, limitNumber, pageNumber, String(req.url))

    // Generate breadcrumbs by traversing up the folder hierarchy
    const breadcrumbs = [];
    let currentFolderId = folderId;

    while (currentFolderId) {
      const folder = await File.findOne({
        fileId: currentFolderId,
        userId: userId,
        type: "folder"
      }).select("-_id fileId fileName parentId").lean();

      if (!folder) break;

      breadcrumbs.unshift(folder); // Add to start of array to maintain correct order
      currentFolderId = folder.parentId;
    }

    return formatApiResponse(res, { paginated: paginatedFiles, breadcrumbs, folder: folder.toJSON() })

  } catch (error) {
    if (error instanceof ApiError) {
      return formatApiResponse(res, error);
    }
    console.error("Error fetching folder contents:", error);
    return formatApiResponse(res, new ApiError(ErrorCode.INTERNAL_ERROR, "Error while loading folder contents", HttpStatus.INTERNAL_SERVER_ERROR));
  }
}

export default authMiddleware(handler)